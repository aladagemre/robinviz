\hypertarget{handlers_8h}{
\section{handlers.h File Reference}
\label{handlers_8h}\index{handlers.h@{handlers.h}}
}
{\tt \#include \char`\"{}interpretBiclusters.h\char`\"{}}\par
{\tt \#include \char`\"{}runFunctions.h\char`\"{}}\par
{\tt \#include \char`\"{}kmeans.h\char`\"{}}\par
{\tt \#include \char`\"{}graphToMatrix.h\char`\"{}}\par
{\tt \#include \char`\"{}saveGraph.h\char`\"{}}\par
{\tt \#include \char`\"{}getBiclusters.h\char`\"{}}\par
\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef struct \hyperlink{structStrings}{Strings} \hyperlink{handlers_8h_9d665a5da789a298bc9c1eb83fc1ae98}{STRINGS}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
void \hyperlink{handlers_8h_6d1b290492b7dfc9eb837564eed39934}{biclusterHandling} (matrix \&INPUT, list$<$ list$<$ \hyperlink{structgenes}{GENES} $>$ $>$ \&biclusters, list$<$ leda::matrix $>$ \&matrixBiclusters, list$<$ double $>$ \&H\_\-values, double \&Hmax, int minBicSize, int maxBicSize, int biclustering, int dimension1, int dimension2)
\item 
void \hyperlink{handlers_8h_b66e608fb3e7ce6c55c315785c4c9455}{interactionHandling} (node\_\-array$<$ \hyperlink{structGeneNames}{GENENAMES} $>$ \&temp, array$<$ \hyperlink{structGeneNames}{GENENAMES} $>$ \&GenesNode, GRAPH$<$ int, int $>$ \&INTERACTIONS, GRAPH$<$ int, int $>$ \&TEMPINT, leda::string \&ppiFile)
\item 
void \hyperlink{handlers_8h_553e0249399f22b3c9ce5a443866abfb}{inpGraphProdHandling} (GRAPH$<$ int, int $>$ \&G, array$<$ GRAPH$<$ int, int $>$ $>$ \&listOfGraphs, char abbv\mbox{[}$\,$\mbox{]}, array$<$ char $>$ \&Categories, node\_\-array$<$ \hyperlink{structGeneNames}{GENENAMES} $>$ \&temp, array$<$ \hyperlink{structGeneNames}{GENENAMES} $>$ \&GenesNode, GRAPH$<$ int, int $>$ \&INTERACTIONS, GRAPH$<$ int, int $>$ \&TEMPINT, list$<$ list$<$ \hyperlink{structgenes}{GENES} $>$ $>$ \&biclusters)
\item 
void \hyperlink{handlers_8h_b3d31f0d93c31fa49c61e836ad04de5d}{mainAlgHandlingForEachSubgraph} (node\_\-array$<$ point $>$ \&pos, edge\_\-array$<$ list$<$ point $>$ $>$ \&bends, array$<$ list$<$ node $>$ $>$ \&layers, list$<$ GRAPH$<$ int, int $>$ $>$ \&GraphList, list$<$ GRAPH$<$ leda::string, int $>$ $>$ \&GraphList\_\-S, node\_\-array$<$ double $>$ \&Xpos, node\_\-array$<$ double $>$ \&Ypos, list$<$ node\_\-array$<$ point $>$ $>$ \&POS, list$<$ edge\_\-array$<$ list$<$ point $>$ $>$ $>$ \&BENDS, list$<$ array$<$ list$<$ node $>$ $>$ $>$ \&LAYERS, GRAPH$<$ leda::string, int $>$ \&PROJECT, array$<$ \hyperlink{structGeneNames}{GENENAMES} $>$ \&GenesNode, array$<$ GRAPH$<$ int, int $>$ $>$ \&listOfGraphs, list$<$ list$<$ \hyperlink{structStrings}{Strings} $>$ $>$ \&namesForEachGraph, list$<$ list$<$ \hyperlink{structgenes}{GENES} $>$ $>$ \&biclusters, int \&width, int algorithmFlag, int space, bool xCoordFlag, int increment, bool ledaPostFlag)
\item 
void \hyperlink{handlers_8h_bcaae6c0c6f3f26f6a1d0188879ed6de}{mainAlgHandlingForEachSubgraph2} (node\_\-array$<$ point $>$ \&pos, edge\_\-array$<$ list$<$ point $>$ $>$ \&bends, array$<$ list$<$ node $>$ $>$ \&layers, list$<$ GRAPH$<$ int, int $>$ $>$ \&GraphList, list$<$ GRAPH$<$ leda::string, int $>$ $>$ \&GraphList\_\-S, node\_\-array$<$ double $>$ \&Xpos, node\_\-array$<$ double $>$ \&Ypos, list$<$ node\_\-array$<$ point $>$ $>$ \&POS, list$<$ edge\_\-array$<$ list$<$ point $>$ $>$ $>$ \&BENDS, list$<$ array$<$ list$<$ node $>$ $>$ $>$ \&LAYERS, GRAPH$<$ leda::string, int $>$ \&PROJECT, array$<$ \hyperlink{structGeneNames}{GENENAMES} $>$ \&GenesNode, array$<$ GRAPH$<$ int, int $>$ $>$ \&listOfGraphs, list$<$ list$<$ \hyperlink{structStrings}{Strings} $>$ $>$ \&namesForEachGraph, list$<$ list$<$ \hyperlink{structgenes}{GENES} $>$ $>$ \&biclusters, int \&width, int algorithmFlag, int space, bool xCoordFlag, int increment, bool ledaPostFlag)
\item 
GRAPH$<$ int, int $>$ \hyperlink{handlers_8h_1e597b3f7add9cc8b8cd8d60345d7ce9}{mainGraphHandling} (GRAPH$<$ leda::string, int $>$ \&PROJECT, node\_\-array$<$ int $>$ \&nodesOfProjectStr, array$<$ node $>$ \&nodesOfProjectInt, list$<$ GRAPH$<$ int, int $>$ $>$ \&GraphList, list$<$ GRAPH$<$ leda::string, int $>$ $>$ \&GraphList\_\-S, list$<$ list$<$ \hyperlink{structStrings}{Strings} $>$ $>$ \&namesForEachGraph, array$<$ \hyperlink{structGeneNames}{GENENAMES} $>$ \&GenesNode, node\_\-array$<$ double $>$ \&HValues, list$<$ double $>$ \&H\_\-values, node\_\-array$<$ double $>$ \&Xpos, node\_\-array$<$ double $>$ \&Ypos, node\_\-array$<$ point $>$ \&pos, edge\_\-array$<$ list$<$ point $>$ $>$ \&bends, edge\_\-array$<$ int $>$ \&edgeNumbersForStr\_\-, array$<$ edge $>$ \&edgeNumbersForInt\_\-, int algorithmFlag, bool brandFlag, bool brandFlag2, bool ourMethodFlag, double space, int increment, bool ledaPostFlag, double nodeSize, double edgeBendImp, double colorScale, double edgThicknessTher, GRAPH$<$ leda::string, int $>$ \&G1, GRAPH$<$ leda::string, int $>$ \&G2, GRAPH$<$ int, int $>$ \&TEMPINT, GRAPH$<$ int, int $>$ \&G, int simplify, double removeRat, bool sharedGenes, double Hmax, int max\_\-weight, bool edgesBetween)
\end{CompactItemize}


\subsection{Typedef Documentation}
\hypertarget{handlers_8h_9d665a5da789a298bc9c1eb83fc1ae98}{
\index{handlers.h@{handlers.h}!STRINGS@{STRINGS}}
\index{STRINGS@{STRINGS}!handlers.h@{handlers.h}}
\subsubsection[{STRINGS}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf Strings} {\bf STRINGS}}}
\label{handlers_8h_9d665a5da789a298bc9c1eb83fc1ae98}




\subsection{Function Documentation}
\hypertarget{handlers_8h_6d1b290492b7dfc9eb837564eed39934}{
\index{handlers.h@{handlers.h}!biclusterHandling@{biclusterHandling}}
\index{biclusterHandling@{biclusterHandling}!handlers.h@{handlers.h}}
\subsubsection[{biclusterHandling}]{\setlength{\rightskip}{0pt plus 5cm}void biclusterHandling (matrix \& {\em INPUT}, \/  list$<$ list$<$ {\bf GENES} $>$ $>$ \& {\em biclusters}, \/  list$<$ leda::matrix $>$ \& {\em matrixBiclusters}, \/  list$<$ double $>$ \& {\em H\_\-values}, \/  double \& {\em Hmax}, \/  int {\em minBicSize}, \/  int {\em maxBicSize}, \/  int {\em biclustering}, \/  int {\em dimension1}, \/  int {\em dimension2})}}
\label{handlers_8h_6d1b290492b7dfc9eb837564eed39934}


biclusterHandling is a function that handles the bicluster output and responds to the main program by having modifying the passed parameters. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em INPUT}](leda::matrix) input matrix obtained from the given input file sources/data\_\-sources \item[{\em biclusters}](leda::list$<$list$<$GENES$>$$>$)filled with the GENE names provided by the data file \item[{\em matrixBiclusters}](leda::list$<$leda::matrix$>$)is used H-value calculation we need this param to obtain submatrices of biclusters \item[{\em H-values}](leda::list) are used in order to have a corresponding value obtained with the id of biclusters \item[{\em Hmax}](double) Hmax is a value that stores max H-value \item[{\em minBicSize}]to control bicluster sizes \item[{\em maxBicSize}]to control bicluster sizes \item[{\em biclustering}](int) is for choosing different biclustering outputs, We have to do that since each alg. has different output from its tool. \item[{\em dimension1(int)}]size of the data row dimension \item[{\em dimension2(int)}]size of the data column dimension \end{description}
\end{Desc}
\hypertarget{handlers_8h_553e0249399f22b3c9ce5a443866abfb}{
\index{handlers.h@{handlers.h}!inpGraphProdHandling@{inpGraphProdHandling}}
\index{inpGraphProdHandling@{inpGraphProdHandling}!handlers.h@{handlers.h}}
\subsubsection[{inpGraphProdHandling}]{\setlength{\rightskip}{0pt plus 5cm}void inpGraphProdHandling (GRAPH$<$ int, int $>$ \& {\em G}, \/  array$<$ GRAPH$<$ int, int $>$ $>$ \& {\em listOfGraphs}, \/  char {\em abbv}\mbox{[}$\,$\mbox{]}, \/  array$<$ char $>$ \& {\em Categories}, \/  node\_\-array$<$ {\bf GENENAMES} $>$ \& {\em temp}, \/  array$<$ {\bf GENENAMES} $>$ \& {\em GenesNode}, \/  GRAPH$<$ int, int $>$ \& {\em INTERACTIONS}, \/  GRAPH$<$ int, int $>$ \& {\em TEMPINT}, \/  list$<$ list$<$ {\bf GENES} $>$ $>$ \& {\em biclusters})}}
\label{handlers_8h_553e0249399f22b3c9ce5a443866abfb}


inpGraphProdHandling is a function that handles the production of peripheral graphs \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em abbv}](char \mbox{[}\mbox{]}) we need a categories for each organism. It may be too general as we did having 13 categories. abbv stores just a capital letter of categories. \item[{\em Categories}](leda::array$<$char$>$) stores each categories for each \hyperlink{structgenes}{genes} \item[{\em listOfGraphs}](leda::array$<$GRAPH$<$int,int$>$$>$) stores all the graphs in this parameter \item[{\em GenesNode}](leda::array$<$GENENAMES$>$) is used with the graph parameter to obtain the specific Genes corresponding nodes \item[{\em INTERACTIONS}](leda::GRAPH$<$int,int$>$) is PPI graph extracted from sources/ppi\_\-sources/$<$ppiFile$>$ it is original graph obtained with interactionHandling \item[{\em biclusters}]we do not lose the track of bicluster \hyperlink{structgenes}{genes} \item[{\em TEMPINT}](leda::GRAPH$<$int,int$>$) is andother copy PPI graph used for processing \item[{\em ppiFile}](leda::string) is obtained from main menu \end{description}
\end{Desc}
\hypertarget{handlers_8h_b66e608fb3e7ce6c55c315785c4c9455}{
\index{handlers.h@{handlers.h}!interactionHandling@{interactionHandling}}
\index{interactionHandling@{interactionHandling}!handlers.h@{handlers.h}}
\subsubsection[{interactionHandling}]{\setlength{\rightskip}{0pt plus 5cm}void interactionHandling (node\_\-array$<$ {\bf GENENAMES} $>$ \& {\em temp}, \/  array$<$ {\bf GENENAMES} $>$ \& {\em GenesNode}, \/  GRAPH$<$ int, int $>$ \& {\em INTERACTIONS}, \/  GRAPH$<$ int, int $>$ \& {\em TEMPINT}, \/  leda::string \& {\em ppiFile})}}
\label{handlers_8h_b66e608fb3e7ce6c55c315785c4c9455}


interactionHandling is a function that handles the PPI extraction from given file \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em temp}](leda::node\_\-array$<$GENENAMES$>$) temp file for proceessing \item[{\em GenesNode}](leda::array$<$GENENAMES$>$) is used with the graph parameter to obtain the specific Genes corresponding nodes \item[{\em INTERACTIONS}](leda::GRAPH$<$int,int$>$) is PPI graph extracted from sources/ppi\_\-sources/$<$ppiFile$>$ \item[{\em TEMPINT}](leda::GRAPH$<$int,int$>$) is andother copy PPI graph used for processing \item[{\em ppiFile}](leda::string) is obtained from main menu \end{description}
\end{Desc}
\hypertarget{handlers_8h_b3d31f0d93c31fa49c61e836ad04de5d}{
\index{handlers.h@{handlers.h}!mainAlgHandlingForEachSubgraph@{mainAlgHandlingForEachSubgraph}}
\index{mainAlgHandlingForEachSubgraph@{mainAlgHandlingForEachSubgraph}!handlers.h@{handlers.h}}
\subsubsection[{mainAlgHandlingForEachSubgraph}]{\setlength{\rightskip}{0pt plus 5cm}void mainAlgHandlingForEachSubgraph (node\_\-array$<$ point $>$ \& {\em pos}, \/  edge\_\-array$<$ list$<$ point $>$ $>$ \& {\em bends}, \/  array$<$ list$<$ node $>$ $>$ \& {\em layers}, \/  list$<$ GRAPH$<$ int, int $>$ $>$ \& {\em GraphList}, \/  list$<$ GRAPH$<$ leda::string, int $>$ $>$ \& {\em GraphList\_\-S}, \/  node\_\-array$<$ double $>$ \& {\em Xpos}, \/  node\_\-array$<$ double $>$ \& {\em Ypos}, \/  list$<$ node\_\-array$<$ point $>$ $>$ \& {\em POS}, \/  list$<$ edge\_\-array$<$ list$<$ point $>$ $>$ $>$ \& {\em BENDS}, \/  list$<$ array$<$ list$<$ node $>$ $>$ $>$ \& {\em LAYERS}, \/  GRAPH$<$ leda::string, int $>$ \& {\em PROJECT}, \/  array$<$ {\bf GENENAMES} $>$ \& {\em GenesNode}, \/  array$<$ GRAPH$<$ int, int $>$ $>$ \& {\em listOfGraphs}, \/  list$<$ list$<$ {\bf Strings} $>$ $>$ \& {\em namesForEachGraph}, \/  list$<$ list$<$ {\bf GENES} $>$ $>$ \& {\em biclusters}, \/  int \& {\em width}, \/  int {\em algorithmFlag}, \/  int {\em space}, \/  bool {\em xCoordFlag}, \/  int {\em increment}, \/  bool {\em ledaPostFlag})}}
\label{handlers_8h_b3d31f0d93c31fa49c61e836ad04de5d}


mainAlgHandlingForEachSubgraph is a function that handles the layering of peripheral graphs using weighted layered drawing concept \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em abbv}](char \mbox{[}\mbox{]}) we need a categories for each organism. It may be too general as we did having 13 categories. abbv stores just a capital letter of categories. \item[{\em Categories}](leda::array$<$char$>$) stores each categories for each \hyperlink{structgenes}{genes} \item[{\em listOfGraphs}](leda::array$<$GRAPH$<$int,int$>$$>$) stores all the graphs in this parameter \item[{\em GenesNode}](leda::array$<$GENENAMES$>$) is used with the graph parameter to obtain the specific Genes corresponding nodes \item[{\em biclusters}]we do not lose the track of bicluster genes(GENES) \item[{\em TEMPINT}](leda::GRAPH$<$int,int$>$) is andother copy PPI graph used for processing \item[{\em ppiFile}](leda::string) is obtained from main menu \item[{\em POS}]Positions of all graphs stored in leda list \item[{\em LAYERS}]Layer Numbers of all graphs stored in leda list \item[{\em BENDS}]Edge bends meanly the points where edge passes and for all graphs \item[{\em pos}]INTERACTION graph node positions \item[{\em layers}]INTERACTION graph node layer numbers \item[{\em bends}]INTERACTION graph edge bends \item[{\em namesForEachGraph}]have the gene names(GENENAMES) for each bicluster \item[{\em width}](int) operational param 1; max width for layering \item[{\em algorithmFlag}](int) operational param 2; chooses x-coordinate alg. \item[{\em space}](int) operational param 3; space between nodes \item[{\em xCoordFlag}](bool) operational param 4; our preliminary method for runnin layering \item[{\em increment}]operational param 5; space between layers \item[{\em ledaPostFlag}](bool) operational param 6; if you need some post-process after x-coordinate assignment \end{description}
\end{Desc}
\hypertarget{handlers_8h_bcaae6c0c6f3f26f6a1d0188879ed6de}{
\index{handlers.h@{handlers.h}!mainAlgHandlingForEachSubgraph2@{mainAlgHandlingForEachSubgraph2}}
\index{mainAlgHandlingForEachSubgraph2@{mainAlgHandlingForEachSubgraph2}!handlers.h@{handlers.h}}
\subsubsection[{mainAlgHandlingForEachSubgraph2}]{\setlength{\rightskip}{0pt plus 5cm}void mainAlgHandlingForEachSubgraph2 (node\_\-array$<$ point $>$ \& {\em pos}, \/  edge\_\-array$<$ list$<$ point $>$ $>$ \& {\em bends}, \/  array$<$ list$<$ node $>$ $>$ \& {\em layers}, \/  list$<$ GRAPH$<$ int, int $>$ $>$ \& {\em GraphList}, \/  list$<$ GRAPH$<$ leda::string, int $>$ $>$ \& {\em GraphList\_\-S}, \/  node\_\-array$<$ double $>$ \& {\em Xpos}, \/  node\_\-array$<$ double $>$ \& {\em Ypos}, \/  list$<$ node\_\-array$<$ point $>$ $>$ \& {\em POS}, \/  list$<$ edge\_\-array$<$ list$<$ point $>$ $>$ $>$ \& {\em BENDS}, \/  list$<$ array$<$ list$<$ node $>$ $>$ $>$ \& {\em LAYERS}, \/  GRAPH$<$ leda::string, int $>$ \& {\em PROJECT}, \/  array$<$ {\bf GENENAMES} $>$ \& {\em GenesNode}, \/  array$<$ GRAPH$<$ int, int $>$ $>$ \& {\em listOfGraphs}, \/  list$<$ list$<$ {\bf Strings} $>$ $>$ \& {\em namesForEachGraph}, \/  list$<$ list$<$ {\bf GENES} $>$ $>$ \& {\em biclusters}, \/  int \& {\em width}, \/  int {\em algorithmFlag}, \/  int {\em space}, \/  bool {\em xCoordFlag}, \/  int {\em increment}, \/  bool {\em ledaPostFlag})}}
\label{handlers_8h_bcaae6c0c6f3f26f6a1d0188879ed6de}


mainAlgHandlingForEachSubgraph is a function that handles the force directed layout of peripheral graphs \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em abbv}](char \mbox{[}\mbox{]}) we need a categories for each organism. It may be too general as we did having 13 categories. abbv stores just a capital letter of categories. \item[{\em Categories}](leda::array$<$char$>$) stores each categories for each \hyperlink{structgenes}{genes} \item[{\em listOfGraphs}](leda::array$<$GRAPH$<$int,int$>$$>$) stores all the graphs in this parameter \item[{\em GenesNode}](leda::array$<$GENENAMES$>$) is used with the graph parameter to obtain the specific Genes corresponding nodes \item[{\em biclusters}]we do not lose the track of bicluster genes(GENES) \item[{\em TEMPINT}](leda::GRAPH$<$int,int$>$) is andother copy PPI graph used for processing \item[{\em ppiFile}](leda::string) is obtained from main menu \item[{\em POS}]Positions of all graphs stored in leda list \item[{\em BENDS}]Edge bends meanly the points where edge passes and for all graphs \item[{\em pos}]INTERACTION graph node positions \item[{\em bends}]INTERACTION graph edge bends \item[{\em namesForEachGraph}]have the gene names(GENENAMES) for each bicluster \item[{\em width}](int) operational param 1; max width for layering \item[{\em algorithmFlag}](int) operational param 2; chooses x-coordinate alg. \item[{\em space}](int) operational param 3; space between nodes \item[{\em xCoordFlag}](bool) operational param 4; our preliminary method for runnin layering \item[{\em increment}]operational param 5; space between layers \item[{\em ledaPostFlag}](bool) operational param 6; if you need some post-process after x-coordinate assignment \end{description}
\end{Desc}
\hypertarget{handlers_8h_1e597b3f7add9cc8b8cd8d60345d7ce9}{
\index{handlers.h@{handlers.h}!mainGraphHandling@{mainGraphHandling}}
\index{mainGraphHandling@{mainGraphHandling}!handlers.h@{handlers.h}}
\subsubsection[{mainGraphHandling}]{\setlength{\rightskip}{0pt plus 5cm}GRAPH$<$int,int$>$ mainGraphHandling (GRAPH$<$ leda::string, int $>$ \& {\em PROJECT}, \/  node\_\-array$<$ int $>$ \& {\em nodesOfProjectStr}, \/  array$<$ node $>$ \& {\em nodesOfProjectInt}, \/  list$<$ GRAPH$<$ int, int $>$ $>$ \& {\em GraphList}, \/  list$<$ GRAPH$<$ leda::string, int $>$ $>$ \& {\em GraphList\_\-S}, \/  list$<$ list$<$ {\bf Strings} $>$ $>$ \& {\em namesForEachGraph}, \/  array$<$ {\bf GENENAMES} $>$ \& {\em GenesNode}, \/  node\_\-array$<$ double $>$ \& {\em HValues}, \/  list$<$ double $>$ \& {\em H\_\-values}, \/  node\_\-array$<$ double $>$ \& {\em Xpos}, \/  node\_\-array$<$ double $>$ \& {\em Ypos}, \/  node\_\-array$<$ point $>$ \& {\em pos}, \/  edge\_\-array$<$ list$<$ point $>$ $>$ \& {\em bends}, \/  edge\_\-array$<$ int $>$ \& {\em edgeNumbersForStr\_\-}, \/  array$<$ edge $>$ \& {\em edgeNumbersForInt\_\-}, \/  int {\em algorithmFlag}, \/  bool {\em brandFlag}, \/  bool {\em brandFlag2}, \/  bool {\em ourMethodFlag}, \/  double {\em space}, \/  int {\em increment}, \/  bool {\em ledaPostFlag}, \/  double {\em nodeSize}, \/  double {\em edgeBendImp}, \/  double {\em colorScale}, \/  double {\em edgThicknessTher}, \/  GRAPH$<$ leda::string, int $>$ \& {\em G1}, \/  GRAPH$<$ leda::string, int $>$ \& {\em G2}, \/  GRAPH$<$ int, int $>$ \& {\em TEMPINT}, \/  GRAPH$<$ int, int $>$ \& {\em G}, \/  int {\em simplify}, \/  double {\em removeRat}, \/  bool {\em sharedGenes}, \/  double {\em Hmax}, \/  int {\em max\_\-weight}, \/  bool {\em edgesBetween})}}
\label{handlers_8h_1e597b3f7add9cc8b8cd8d60345d7ce9}


mainGraphHandling is a function that handles the ISB 2010 submitted main layout on the peripheral graphs \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em abbv}](char \mbox{[}\mbox{]}) we need a categories for each organism. It may be too general as we did having 13 categories. abbv stores just a capital letter of categories. \item[{\em Categories}](leda::array$<$char$>$) stores each categories for each \hyperlink{structgenes}{genes} \item[{\em listOfGraphs}](leda::array$<$GRAPH$<$int,int$>$$>$) stores all the graphs in this parameter \item[{\em GenesNode}](leda::array$<$GENENAMES$>$) is used with the graph parameter to obtain the specific Genes corresponding nodes \item[{\em biclusters}]we do not lose the track of bicluster genes(GENES) \item[{\em TEMPINT}](leda::GRAPH$<$int,int$>$) is andother copy PPI graph used for processing \item[{\em ppiFile}](leda::string) is obtained from main menu \item[{\em POS}]Positions of all graphs stored in leda list \item[{\em BENDS}]Edge bends meanly the points where edge passes and for all graphs \item[{\em pos}]INTERACTION graph node positions \item[{\em bends}]INTERACTION graph edge bends \item[{\em namesForEachGraph}]have the gene names(GENENAMES) for each bicluster \item[{\em width}](int) operational param 1; max width for layering \item[{\em algorithmFlag}](int) operational param 2; chooses x-coordinate alg. \item[{\em space}](int) operational param 3; space between nodes \item[{\em xCoordFlag}](bool) operational param 4; our preliminary method for runnin layering \item[{\em increment}]operational param 5; space between layers \item[{\em ledaPostFlag}](bool) operational param 6; if you need some post-process after x-coordinate assignment \item[{\em removeRat(double)}]operational param 7; removes edge weights when they are smaller than this ratio \item[{\em sharedGenes(bool)}]operational param 8: options for having a methodology to use shared Genes options specifed in the paper \item[{\em max\_\-weight(int)}]largets weight \item[{\em edgesBetween(bool)}]operational param 9: the second method rather than shared Genes expained in the paper \end{description}
\end{Desc}
